#!/usr/bin/env bash

# Function to get system information
get_system_info() {
    local os_info=""
    local shell_info=""
    local arch_info=""
    local current_dir="$(pwd)"
    
    # Detect OS
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        os_info="Linux"
        if command -v lsb_release >/dev/null 2>&1; then
            os_info="$(lsb_release -d -s 2>/dev/null || echo "Linux")"
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        os_info="macOS $(sw_vers -productVersion 2>/dev/null || echo "Unknown")"
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        os_info="Windows (Git Bash)"
    else
        os_info="$OSTYPE"
    fi
    
    # Get shell info
    shell_info="$SHELL $(bash --version | head -n1 | cut -d' ' -f4 2>/dev/null || echo "Unknown")"
    
    # Get architecture
    arch_info="$(uname -m 2>/dev/null || echo "Unknown")"
    
    # Return as single line for JSON compatibility
    echo "System Context: - OS: $os_info - Shell: $shell_info - Architecture: $arch_info - Current Directory: $current_dir"
}

# Function to display usage examples
show_usage_examples() {
    echo ""
    echo -e "\033[93mUsage examples:\033[0m"
    echo -e -n "\033[96m  ask help\033[0m"; echo -e -n "\033[96m                          \033[0m"; echo -e "\033[92m# Show help information\033[0m"    
    echo -e -n "\033[96m  ask \033[0m"; echo -e -n "\033[96m\"What is Git?\"\033[0m"; echo -e -n "\033[96m                \033[0m"; echo -e "\033[92m# Ask AI directly\033[0m"
    echo -e -n "\033[96m  ask \033[0m"; echo -e -n "\033[96m\"ls -la\" \"How many files?\"\033[0m"; echo -e -n "\033[96m    \033[0m"; echo -e "\033[92m# Run command, ask AI about result\033[0m"
    echo -e -n "\033[96m  ask \033[0m"; echo -e -n "\033[96m\"ps aux\" \"Top memory usage?\"\033[0m"; echo -e -n "\033[96m  \033[0m"; echo -e "\033[92m \033[0m"
    echo -e -n "\033[96m  ask uninstall\033[0m"; echo -e -n "\033[96m                     \033[0m"; echo -e "\033[92m# Remove global command\033[0m"
}

# Function to install bash alias
install_ask_alias() {
    local script_path="$(realpath "${BASH_SOURCE[0]}")"
    local bashrc_file=""
    local profile_file=""
    
    # Determine which bash config files to use
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS uses .bash_profile by default
        bashrc_file="$HOME/.bash_profile"
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        # Git Bash on Windows - use .bash_profile and ensure it sources .bashrc
        bashrc_file="$HOME/.bashrc"
        profile_file="$HOME/.bash_profile"
    else
        # Linux uses .bashrc
        bashrc_file="$HOME/.bashrc"
    fi
    
    echo -e "\033[96mInstalling ask alias for bash...\033[0m"
    echo -e "\033[96mScript path: $script_path\033[0m"
    
    # Handle Git Bash on Windows special case
    if [[ -n "$profile_file" ]]; then
        echo -e "\033[96mConfig files: $bashrc_file (via $profile_file)\033[0m"
        
        # Create .bashrc if it doesn't exist
        if [[ ! -f "$bashrc_file" ]]; then
            echo -e "\033[96mCreating bash config file: $bashrc_file\033[0m"
            touch "$bashrc_file"
        fi
        
        # Create .bash_profile if it doesn't exist and make it source .bashrc
        if [[ ! -f "$profile_file" ]]; then
            echo -e "\033[96mCreating bash profile file: $profile_file\033[0m"
            cat > "$profile_file" << 'EOF'
# Generated by ask install
if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi
EOF
        else
            # Check if .bash_profile already sources .bashrc
            if ! grep -q "source.*bashrc\|\..*bashrc" "$profile_file" 2>/dev/null; then
                echo -e "\033[96mAdding .bashrc source to $profile_file\033[0m"
                echo "" >> "$profile_file"
                echo "# Source .bashrc - added by ask install" >> "$profile_file"
                echo "if [ -f ~/.bashrc ]; then source ~/.bashrc; fi" >> "$profile_file"
            fi
        fi
    else
        echo -e "\033[96mConfig file: $bashrc_file\033[0m"
        
        # Create config file if it doesn't exist
        if [[ ! -f "$bashrc_file" ]]; then
            echo -e "\033[96mCreating bash config file: $bashrc_file\033[0m"
            touch "$bashrc_file"
        fi
    fi
    
    # Add alias to the appropriate file
    local target_file="$bashrc_file"
    
    # Check if alias already exists
    if grep -q "alias ask=" "$target_file" 2>/dev/null; then
        echo -e "\033[96mAsk alias already exists in $target_file\033[0m"
    else
        echo -e "\033[96mAdding ask alias to $target_file\033[0m"
        echo "" >> "$target_file"
        echo "# Ask Terminal Chat alias - generated by ask install" >> "$target_file"
        echo "alias ask='bash \"$script_path\"'" >> "$target_file"
        echo "echo -e \"\033[96mAsk Terminal Chat function loaded. Use \033[93m'ask help'\033[96m for more information.\033[0m\"" >> "$target_file"
        echo -e "\033[96mAsk alias added successfully!\033[0m"
    fi
    
    echo -e "\033[96mInstallation complete!\033[0m"
    echo -e "\033[93mPlease restart your terminal or run: source ~/.bash_profile\033[0m"
    
    show_usage_examples
    
    exit 0
}

# Function to uninstall bash alias
uninstall_ask_alias() {
    local bashrc_file=""
    local profile_file=""
    
    # Determine which bash config files to use
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS uses .bash_profile by default
        bashrc_file="$HOME/.bash_profile"
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        # Git Bash on Windows - check both files
        bashrc_file="$HOME/.bashrc"
        profile_file="$HOME/.bash_profile"
    else
        # Linux uses .bashrc
        bashrc_file="$HOME/.bashrc"
    fi
    
    echo -e "\033[96mRemoving ask alias...\033[0m"
    
    # Remove from .bashrc (or .bash_profile on macOS)
    if [[ -f "$bashrc_file" ]]; then
        if grep -q "alias ask=" "$bashrc_file"; then
            # Create temp file without the ask alias lines
            grep -v "# Ask Terminal Chat alias" "$bashrc_file" | grep -v "alias ask=" | grep -v "Ask Terminal Chat function loaded" > "${bashrc_file}.tmp"
            mv "${bashrc_file}.tmp" "$bashrc_file"
            echo -e "\033[96mRemoved ask alias from: $bashrc_file\033[0m"
        fi
    fi
    
    # For Git Bash, also check if we need to clean up .bash_profile
    if [[ -n "$profile_file" && -f "$profile_file" ]]; then
        # Check if .bash_profile was created by us and only contains our bashrc sourcing
        if grep -q "Generated by ask install" "$profile_file" && 
           [ "$(grep -v '^#\|^$\|source.*bashrc\|\..*bashrc' "$profile_file" | wc -l)" -eq 0 ]; then
            echo -e "\033[96mRemoving auto-generated bash profile: $profile_file\033[0m"
            rm "$profile_file"
        else
            # Remove only our bashrc sourcing lines if they exist
            if grep -q "Source .bashrc - added by ask install" "$profile_file"; then
                grep -v "Source .bashrc - added by ask install" "$profile_file" | 
                grep -v "if \[ -f ~/.bashrc \]; then source ~/.bashrc; fi" > "${profile_file}.tmp"
                mv "${profile_file}.tmp" "$profile_file"
                echo -e "\033[96mRemoved bashrc sourcing from: $profile_file\033[0m"
            fi
        fi
    fi
    
    echo -e "\033[96mRemoved ask alias from bash profile.\033[0m"
    echo -e "\033[96mUninstallation complete!\033[0m"
    echo -e "\033[93mPlease restart your terminal or run: source ~/.bash_profile\033[0m"
    
    exit 0
}

# Function to ensure virtual environment is activated
ensure_virtual_env() {
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local venv_path="$script_dir/../.virtualenv"
    
    # On Windows (Git Bash), activation script is in Scripts directory
    # On Unix, it's in bin directory
    local activate_script=""
    if [ -f "$venv_path/Scripts/activate" ]; then
        activate_script="$venv_path/Scripts/activate"
    elif [ -f "$venv_path/bin/activate" ]; then
        activate_script="$venv_path/bin/activate"
    fi
    
    # Check if virtual environment is already active
    if [ -z "$VIRTUAL_ENV" ]; then
        if [ -f "$activate_script" ]; then
            echo "Activating virtual environment..."
            source "$activate_script"
        else
            echo "Error: Virtual environment not found at $venv_path"
            echo "Looked for activation script at:"
            echo "  $venv_path/Scripts/activate"
            echo "  $venv_path/bin/activate"
            exit 1
        fi
    fi
}

# Function to find project root directory
find_project_root() {
    local current_path="$(dirname "$(realpath "$0")")"
    local max_depth=10
    local depth=0
    
    while [[ $depth -lt $max_depth ]]; do
        # Look for indicator of project root (mcp_server directory)
        if [[ -d "$current_path/mcp_server" ]]; then
            # echo "Found project root at: $current_path"
            echo "$current_path"
            return 0
        fi
        
        # Move up one directory
        local parent_path="$(dirname "$current_path")"
        if [[ "$parent_path" == "$current_path" ]]; then
            # Reached filesystem root, use script directory
            echo "$(dirname "$(realpath "$0")")"
            return 1
        fi
        
        current_path="$parent_path"
        ((depth++))
    done
    
    # Max depth reached, use script directory
    echo "$(dirname "$(realpath "$0")")"
    return 1
}

# Ensure virtual environment is activated
ensure_virtual_env

## color stuff

green="[92m"
blue="[94m"
yellow="[93m"
red="[91m"
end="[0m"

color() {
    message=$1
    color=$2

    echo
    echo -e "$color$message$end"
    echo
}

## other logic

#!/usr/bin/env bash

# GPT Terminal Chat Script
# Usage: 
#   bash gpt "question"                 # Simple question mode
#   bash gpt "command" "question"       # Command analysis mode

# Set UTF-8 encoding
export PYTHONIOENCODING=utf-8
export LC_ALL=C.UTF-8
export LANG=C.UTF-8

green="\033[92m"
blue="\033[94m"
yellow="\033[93m"
red="\033[91m"
white="\033[97m"
end="\033[0m"

color() {
    message=$1
    color=$2
    echo -e "$color$message$end"
}

# Check for special commands first
if [ "$1" = "install" ]; then
    install_ask_alias
elif [ "$1" = "uninstall" ]; then
    uninstall_ask_alias
elif [ "$1" = "help" ] || [ $# -eq 0 ]; then
    # Show help message
    echo -e "\033[96mAsk Terminal Chat - AI assistant for command line\033[0m"
    echo ""
    echo -e "\033[97mThis tool helps you get answers about commands and general questions using AI.\033[0m"
    echo -e "\033[97mSystem context (OS, shell, directory) is automatically included for better answers.\033[0m"
    echo ""
    echo -e "\033[93mInstallation:\033[0m"
    echo -e -n "\033[96m  ask install\033[0m"; echo -e -n "\033[96m                       \033[0m"; echo -e "\033[92m# Install global 'ask' command (recommended)\033[0m"
    
    show_usage_examples
    exit 0
fi

# Check number of arguments
if [ $# -eq 1 ]; then
    # Simple question mode
    question=$1
    
    color "Question: $question" $yellow
    
    # Find and change to project root directory
    project_root=$(find_project_root)
    cd "$project_root"
    
    # Get system information
    system_info=$(get_system_info)
    
    # Create temporary file for JSON to avoid escaping issues
    temp_file=$(mktemp)
    cat > "$temp_file" << EOF
{"command":"echo 'Simple question mode'","command_output":"This is a direct question to the LLM without executing any command.","question":"$question","system_info":"$system_info"}
EOF
    
    # Call MCP tool using temp file with UTF-8 encoding
    response=$(PYTHONIOENCODING=utf-8 python -m mcp_server.run run lng_terminal_chat "$(cat "$temp_file")" 2>&1)
    mcp_exit_code=$?
    
    # Clean up temp file
    rm "$temp_file"
    
    if [ $mcp_exit_code -ne 0 ]; then
        color "Error: $response" $red
        exit 1
    fi
    
    # Extract result and display - more robust parsing for emojis
    result=$(echo "$response" | sed -n '/📤 Result:/,$p' | sed '1d' | head -n -1)
    if [ -z "$result" ]; then
        # Fallback: try without emoji
        result=$(echo "$response" | sed -n '/Result:/,$p' | sed '1d')
    fi
    if [ -z "$result" ]; then
        result="$response"
    fi
    
    color "Answer: $result" $green
    
elif [ $# -eq 2 ]; then
    # Command analysis mode
    command=$1
    question=$2
    
    color "Question: $question" $yellow
    color "> $command" $blue
    
    # Execute command and capture output
    output=$(eval "$command" 2>&1)
    exit_code=$?
    
    # Display command output
    color "$output" $white
    
    # Find and change to project root directory
    project_root=$(find_project_root)
    cd "$project_root"
    
    # Get system information
    system_info=$(get_system_info)
    
    # Create temporary file for JSON to avoid escaping issues
    temp_file=$(mktemp)
    
    # Escape the output for JSON (replace newlines with \n and escape quotes)
    escaped_output=$(echo "$output" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
    escaped_command=$(echo "$command" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
    escaped_question=$(echo "$question" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
    escaped_system_info=$(echo "$system_info" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
    
    cat > "$temp_file" << EOF
{"command":"$escaped_command","command_output":"$escaped_output","question":"$escaped_question","system_info":"$escaped_system_info"}
EOF
    
    # Call MCP tool using temp file with UTF-8 encoding
    response=$(PYTHONIOENCODING=utf-8 python -m mcp_server.run run lng_terminal_chat "$(cat "$temp_file")" 2>&1)
    mcp_exit_code=$?
    
    # Clean up temp file
    rm "$temp_file"
    
    if [ $mcp_exit_code -ne 0 ]; then
        color "Error: $response" $red
        exit 1
    fi
    
    # Extract result and display - more robust parsing for emojis
    result=$(echo "$response" | sed -n '/📤 Result:/,$p' | sed '1d' | head -n -1)
    if [ -z "$result" ]; then
        # Fallback: try without emoji
        result=$(echo "$response" | sed -n '/Result:/,$p' | sed '1d')
    fi
    if [ -z "$result" ]; then
        result="$response"
    fi
    
    color "Answer: $result" $green
    
else
    echo -e "\033[91mUsage:\033[0m"
    echo -e -n "\033[93m  bash ask \033[0m"; echo -e -n "\033[93m\"<question>\"\033[0m"; echo -e -n "\033[93m                    \033[0m"; echo -e "\033[92m# Simple question mode\033[0m"
    echo -e -n "\033[93m  bash ask \033[0m"; echo -e -n "\033[93m\"<command>\" \"<question>\"\033[0m"; echo -e -n "\033[93m        \033[0m"; echo -e "\033[92m# Command analysis mode\033[0m"
    echo -e -n "\033[93m  bash ask install\033[0m"; echo -e -n "\033[93m                          \033[0m"; echo -e "\033[92m# Install global alias\033[0m"
    echo -e -n "\033[93m  bash ask uninstall\033[0m"; echo -e -n "\033[93m                        \033[0m"; echo -e "\033[92m# Remove global alias\033[0m"
    echo -e "\033[96mExamples:\033[0m"
    echo -e -n "\033[96m  bash ask \033[0m"; echo -e -n "\033[96m\"What is the capital of France?\"\033[0m"; echo -e "\033[92m\033[0m"
    echo -e -n "\033[96m  bash ask \033[0m"; echo -e -n "\033[96m\"ls -la\" \"How many files are there?\"\033[0m"; echo -e "\033[92m\033[0m"
    exit 1
fi
