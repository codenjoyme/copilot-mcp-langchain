# Multi-Agent Architecture Summary

## Overview

Мультиагентная система для LangChain, которая позволяет делегировать анализ кода специализированным субагентам.

## Ключевые компоненты

### 1. Оркестратор (Copilot)
- Главный агент, координирующий работу
- **НЕ** работает напрямую с файлами делегированных модулей
- Собирает информацию от субагентов перед принятием решений
- Выполняет финальные изменения после анализа

### 2. Субагенты (Sub-Agents)
- Каждый отвечает за конкретный модуль/директорию
- Имеют доступ к выбранным инструментам из tool_registry.py
- Используют LangChain memory для хранения контекста разговоров
- Возвращают саммари анализа, а не полные логи

### 3. Менеджер агентов (MultiAgentManager)
- `lng_multi_agent_manager` - основной MCP инструмент
- Управляет жизненным циклом субагентов
- Сохраняет конфигурации в `mcp_server/config/multi_agent/agents.json`
- Обрабатывает запросы к субагентам

## Принцип работы

```
Пользователь → Copilot (Оркестратор)
                  ↓
            MultiAgentManager
                  ↓
            SubAgent 1 → Модуль A
            SubAgent 2 → Модуль B  
            SubAgent 3 → Модуль C
```

## Основные операции

### Создание субагента
```json
{
  "operation": "create_agent",
  "name": "Frontend Agent",
  "module_path": "/src/components", 
  "available_tools": ["lng_file_read", "lng_file_list"],
  "description": "Анализирует компоненты React"
}
```

### Запрос к субагенту
```json
{
  "operation": "query_agent",
  "agent_id": "uuid",
  "question": "Какие файлы в этом модуле?"
}
```

### Список агентов
```json
{
  "operation": "list_agents"
}
```

## Преимущества

- ✅ **Модульность**: Каждый агент специализируется на своей области
- ✅ **Параллелизм**: Агенты могут работать одновременно
- ✅ **Память**: Субагенты помнят предыдущие разговоры
- ✅ **KISS**: Простое решение без избыточного RAG
- ✅ **Масштабируемость**: Легко добавлять новые модули
- ✅ **Инструменты**: Гибкое назначение инструментов каждому агенту

## Ограничения

- Субагенты только читают код (пока нет инструментов записи)
- Требует Azure OpenAI для работы LLM агентов
- Оркестратор должен следовать инструкциям делегирования

## Файловая структура

```
mcp_server/tools/lng_multi_agent/
├── manager/tool.py           # Основной MCP инструмент
├── readme.md                 # Техническая документация
├── DEMO.md                   # Демо использования
├── ARCHITECTURE.md           # Этот файл
├── settings.yaml            # Настройки модуля
└── stuff/                   # Тестовые скрипты
    ├── test_basic.py        # Базовый тест
    └── test_system.py       # Полный тест с LLM
```

## Конфигурация

Агенты сохраняются в `mcp_server/config/multi_agent/agents.json`:

```json
{
  "agents": [
    {
      "agent_id": "uuid",
      "name": "Agent Name",
      "module_path": "/path/to/module", 
      "available_tools": ["tool1", "tool2"],
      "description": "Agent purpose",
      "created_at": "2025-01-01T00:00:00",
      "last_active": "2025-01-01T00:00:00"
    }
  ]
}
```

## Жизненный цикл агентов

### Загрузка и хранение
- Агенты загружаются из `agents.json` при старте MCP сервера
- Хранятся в оперативной памяти сервера
- LLM активируется только при вызове `query_agent`

### Управление памятью
- **Память агентов**: Только в RAM, теряется при рестарте
- **Конфигурация**: Сохраняется на диск автоматически
- **История разговоров**: Не персистентна (ConversationBufferWindowMemory)

### Очистка агентов
```json
{"agents": []}
```
Пустой массив в `agents.json` = нет агентов после перезапуска сервера.
