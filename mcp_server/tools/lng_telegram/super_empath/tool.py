"""
Super Empath - –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞
"""

import asyncio
import json
import uuid
import os
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict

import mcp.types as types
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.error import TelegramError

from mcp_server.logging_config import setup_instance_logger, close_instance_logger

# –õ–æ–≥–≥–µ—Ä –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏
logger = setup_instance_logger("super_empath", "telegram")

async def tool_info() -> dict:
    """Returns information about the lng_telegram_super_empath tool."""
    return {
        "description": "Super Empath - –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏ –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö",
        "schema": {
            "type": "object",
            "properties": {
                "operation": {
                    "type": "string",
                    "enum": ["start_bot", "stop_bot", "status", "process_message"],
                    "description": "Operation to perform"
                },
                "message": {
                    "type": "string",
                    "description": "Message to process"
                },
                "user_id": {
                    "type": "integer",
                    "description": "User ID"
                },
                "session_id": {
                    "type": "string", 
                    "description": "Session ID"
                },
                "pipeline": {
                    "type": "array",
                    "description": "Pipeline to execute for message processing",
                    "items": {
                        "type": "object"
                    }
                }
            },
            "required": ["operation"]
        }
    }

@dataclass
class UserState:
    """–°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    user_id: int
    username: str
    first_name: str
    session_id: Optional[str] = None
    current_message_processing: Optional[str] = None
    joined_at: Optional[str] = None

@dataclass
class SessionState:
    """–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Å—Å–∏–∏"""
    session_id: str
    participants: List[int]
    created_at: str
    last_activity: str
    message_queue: List[Dict] = None

    def __post_init__(self):
        if self.message_queue is None:
            self.message_queue = []

class SuperEmpathBot:
    """–ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ Super Empath –±–æ—Ç–∞"""
    
    def __init__(self, token: str, pipeline: List[Dict] = None):
        self.token = token
        self.bot = Bot(token=token)
        self.application = Application.builder().token(token).build()
        self.pipeline = pipeline or []
        
        # –°–æ—Å—Ç–æ—è–Ω–∏—è
        self.users: Dict[int, UserState] = {}
        self.sessions: Dict[str, SessionState] = {}
        self.running = False
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        self._setup_handlers()
        
    def _setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        self.application.add_handler(CommandHandler("start", self._handle_start))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message))
        
    async def _handle_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start"""
        try:
            user = update.effective_user
            user_id = user.id
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä —Å–µ—Å—Å–∏–∏ –∏–∑ deep link
            session_id = None
            if context.args:
                session_id = context.args[0]
                
            logger.info(f"User {user_id} started bot with session_id: {session_id}")
            
            # –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_state = UserState(
                user_id=user_id,
                username=user.username or "",
                first_name=user.first_name or "",
                session_id=session_id,
                joined_at=datetime.now().isoformat()
            )
            self.users[user_id] = user_state
            
            if session_id:
                # –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º—Å—è –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Å–µ—Å—Å–∏–∏
                await self._join_session(user_id, session_id)
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é
                new_session_id = await self._create_session(user_id)
                await self._send_invitation_link(user_id, new_session_id)
                
        except Exception as e:
            logger.error(f"Error in start handler: {e}")
            await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ –±–æ—Ç—É")
            
    async def _handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            user_id = update.effective_user.id
            message_text = update.message.text
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω
            if user_id not in self.users:
                await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É /start")
                return
                
            user_state = self.users[user_id]
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã Super Empath
            if message_text == "—Ç–∞–º–∞–º":
                await self._approve_message(user_id, update)
            elif message_text == "–æ—Ç–±–æ–π":
                await self._cancel_message(user_id, update)
            else:
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–±—ã—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                await self._process_user_message(user_id, message_text, update)
            
        except Exception as e:
            logger.error(f"Error in message handler: {e}")
            await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è")

    async def _create_session(self, user_id: int) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Å–µ—Å—Å–∏–∏"""
        session_id = str(uuid.uuid4())
        session_state = SessionState(
            session_id=session_id,
            participants=[user_id],
            created_at=datetime.now().isoformat(),
            last_activity=datetime.now().isoformat()
        )
        
        self.sessions[session_id] = session_state
        self.users[user_id].session_id = session_id
        
        logger.info(f"Created session {session_id} for user {user_id}")
        return session_id
        
    async def _join_session(self, user_id: int, session_id: str):
        """–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Å–µ—Å—Å–∏–∏"""
        if session_id in self.sessions:
            session = self.sessions[session_id]
            if user_id not in session.participants:
                session.participants.append(user_id)
                session.last_activity = datetime.now().isoformat()
                
            self.users[user_id].session_id = session_id
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
            user_state = self.users[user_id]
            join_message = f"üëã {user_state.first_name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ —Å–µ—Å—Å–∏–∏ Super Empath"
            
            for participant_id in session.participants:
                if participant_id != user_id:
                    await self.bot.send_message(participant_id, join_message)
                    
            await self.bot.send_message(user_id, f"‚úÖ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Super Empath!\n\n–í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ —Å–µ—Å—Å–∏–∏ {session_id}")
            logger.info(f"User {user_id} joined session {session_id}")
        else:
            await self.bot.send_message(user_id, "‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            
    async def _send_invitation_link(self, user_id: int, session_id: str):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Å—ã–ª–∫–∏-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è"""
        bot_username = (await self.bot.get_me()).username
        invite_link = f"https://t.me/{bot_username}?start={session_id}"
        
        message = f"""üéØ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Super Empath!

**Super Empath** - –≤–∞—à —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è –ª—É—á—à–µ–≥–æ –æ–±—â–µ–Ω–∏—è.

–í–∞—à–∞ —Å–µ—Å—Å–∏—è: `{session_id}`
–°—Å—ã–ª–∫–∞ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è: {invite_link}

**–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è:**
1. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —ç—Ç—É —Å—Å—ã–ª–∫—É –≤–∞—à–µ–º—É —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É
2. –ü–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–∞–∫ –æ–±—ã—á–Ω–æ
3. –ë–æ—Ç –ø—Ä–µ–¥–ª–æ–∂–∏—Ç –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏
4. –ì–æ–≤–æ—Ä–∏—Ç–µ "—Ç–∞–º–∞–º" –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–ª–∏ "–æ—Ç–±–æ–π" –¥–ª—è –æ—Ç–º–µ–Ω—ã

–ù–∞—á–Ω–∏—Ç–µ –æ–±—â–µ–Ω–∏–µ! üí¨"""
        
        await self.bot.send_message(user_id, message, parse_mode='Markdown')

    async def _process_user_message(self, user_id: int, message_text: str, update: Update):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ pipeline"""
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            self.users[user_id].current_message_processing = message_text
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º pipeline –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è (–∑–∞–≥–ª—É—à–∫–∞)
            # TODO: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å lng_batch_run
            
            # –ü—Ä–æ—Å—Ç–∞—è –¥–µ–º–æ-–æ–±—Ä–∞–±–æ—Ç–∫–∞
            improved_message = await self._demo_improve_message(message_text)
            
            response = f"""üìù **–í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:**
"{message_text}"

üí° **–ü—Ä–µ–¥–ª–∞–≥–∞—é –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å:**
"{improved_message}"

–ù–∞–ø–∏—à–∏—Ç–µ "—Ç–∞–º–∞–º" –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–ª–∏ "–æ—Ç–±–æ–π" –¥–ª—è –æ—Ç–º–µ–Ω—ã."""
            
            await update.message.reply_text(response, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è")

    async def _demo_improve_message(self, message: str) -> str:
        """–î–µ–º–æ-—Ñ—É–Ω–∫—Ü–∏—è —É–ª—É—á—à–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è (–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è LLM)"""
        # –ü—Ä–æ—Å—Ç—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –¥–µ–º–æ
        message_lower = message.lower()
        
        if any(word in message_lower for word in ["–¥–æ—Å—Ç–∞–ª", "–±–µ—Å–∏—à—å", "–Ω–∞–¥–æ–µ–ª"]):
            return "–Ø —á—É–≤—Å—Ç–≤—É—é —É—Å—Ç–∞–ª–æ—Å—Ç—å –æ—Ç —Å–∏—Ç—É–∞—Ü–∏–∏, –º–æ–∂–µ–º —ç—Ç–æ –æ–±—Å—É–¥–∏—Ç—å?"
        elif any(word in message_lower for word in ["–¥—É—Ä–∞–∫", "–∏–¥–∏–æ—Ç", "—Ç—É–ø–æ–π"]):
            return "–£ –º–µ–Ω—è –µ—Å—Ç—å –¥—Ä—É–≥–æ–µ –º–Ω–µ–Ω–∏–µ –ø–æ —ç—Ç–æ–º—É –≤–æ–ø—Ä–æ—Å—É, –¥–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º—Å—è"
        elif any(word in message_lower for word in ["–Ω–µ —Ö–æ—á—É", "–Ω–µ –±—É–¥—É", "–æ—Ç—Å—Ç–∞–Ω—å"]):
            return "–ú–Ω–µ —Å–µ–π—á–∞—Å —Å–ª–æ–∂–Ω–æ —ç—Ç–æ –¥–µ–ª–∞—Ç—å, –º–æ–∂–µ–º –Ω–∞–π—Ç–∏ –∫–æ–º–ø—Ä–æ–º–∏—Å—Å?"
        elif "!" in message and len(message) > 20:
            return message.replace("!", ".").strip() + " –ß—Ç–æ –¥—É–º–∞–µ—à—å?"
        else:
            return f"–Ø —Ö–æ—Ç–µ–ª —Å–∫–∞–∑–∞—Ç—å: {message}. –ö–∞–∫ —Å—á–∏—Ç–∞–µ—à—å?"

    async def _approve_message(self, user_id: int, update: Update):
        """–û–¥–æ–±—Ä–µ–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        user_state = self.users[user_id]
        
        if not user_state.current_message_processing:
            await update.message.reply_text("–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏")
            return
            
        if not user_state.session_id:
            await update.message.reply_text("–í—ã –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ —Å–µ—Å—Å–∏–∏")
            return
            
        # –ü–æ–ª—É—á–∞–µ–º —É–ª—É—á—à–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        improved_message = await self._demo_improve_message(user_state.current_message_processing)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º —Å–µ—Å—Å–∏–∏ –∫—Ä–æ–º–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
        session = self.sessions[user_state.session_id]
        sent_count = 0
        
        for participant_id in session.participants:
            if participant_id != user_id:
                try:
                    await self.bot.send_message(
                        participant_id, 
                        f"üí¨ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {user_state.first_name}:\n\n{improved_message}"
                    )
                    sent_count += 1
                except Exception as e:
                    logger.error(f"Failed to send message to {participant_id}: {e}")
        
        # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é
        await update.message.reply_text(f"‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {sent_count} —É—á–∞—Å—Ç–Ω–∏–∫–∞–º")
        
        # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        user_state.current_message_processing = None

    async def _cancel_message(self, user_id: int, update: Update):
        """–û—Ç–º–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        user_state = self.users[user_id]
        
        if user_state.current_message_processing:
            user_state.current_message_processing = None
            await update.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
        else:
            await update.message.reply_text("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –æ—Ç–º–µ–Ω—ã")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∏–Ω—Å—Ç–∞–Ω—Å
_bot_instance: Optional[SuperEmpathBot] = None

def close_super_empath_logger():
    """–ó–∞–∫—Ä—ã—Ç–∏–µ –ª–æ–≥–≥–µ—Ä–∞ super_empath"""
    try:
        close_instance_logger("super_empath", "telegram")
    except Exception as e:
        print(f"Error closing super_empath logger: {e}")

def get_bot_status() -> Dict:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –±–æ—Ç–∞"""
    global _bot_instance
    
    if not _bot_instance:
        return {"running": False, "users": 0, "sessions": 0}
        
    return {
        "running": _bot_instance.running,
        "users": len(_bot_instance.users),
        "sessions": len(_bot_instance.sessions),
        "user_list": list(_bot_instance.users.keys()),
        "session_list": list(_bot_instance.sessions.keys())
    }

def tool_lng_telegram_super_empath(
    operation: str,
    message: str = None,
    user_id: int = None,
    session_id: str = None,
    pipeline: List[Dict] = None
) -> Dict[str, Any]:
    """
    Super Empath - –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞
    
    Operations:
    - start_bot: –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ Super Empath
    - stop_bot: –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞
    - status: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
    - process_message: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ LLM
    """
    
    try:
        if operation == "start_bot":
            # –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –ª–æ–≥–≥–µ—Ä –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
            global logger
            close_super_empath_logger()
            logger = setup_instance_logger("super_empath", "telegram")
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ .env
            from dotenv import load_dotenv
            load_dotenv()
            token = os.getenv("TELEGRAM_BOT_TOKEN")
            
            if not token:
                return {"error": "TELEGRAM_BOT_TOKEN not found in .env file"}
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —á–µ—Ä–µ–∑ lng_telegram_polling_server
            import subprocess
            import sys
            
            # –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –∑–∞–ø—É—Å–∫–∞
            config = {
                "operation": "start",
                "token": token,
                "pipeline": pipeline or [
                    {
                        "tool": "lng_telegram_super_empath",
                        "params": {
                            "operation": "process_message",
                            "message": "{! telegram.message !}",
                            "user_id": "{! telegram.user_id !}"
                        },
                        "output": "processed_result"
                    }
                ]
            }
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º existing polling server
            from mcp_server.tools.lng_telegram.polling_server.tool import tool_lng_telegram_polling_server
            
            result = tool_lng_telegram_polling_server(**config)
            
            if "error" not in result:
                return {
                    "status": "started",
                    "message": "Super Empath bot started successfully",
                    "details": result
                }
            else:
                return result
                
        elif operation == "stop_bot":
            from mcp_server.tools.lng_telegram.polling_server.tool import tool_lng_telegram_polling_server
            
            result = tool_lng_telegram_polling_server(operation="stop")
            
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –ª–æ–≥–≥–µ—Ä super_empath –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
            close_super_empath_logger()
            
            return result
            
        elif operation == "status":
            status = get_bot_status()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–∫–∂–µ —Å—Ç–∞—Ç—É—Å polling server
            from mcp_server.tools.lng_telegram.polling_server.tool import tool_lng_telegram_polling_server
            polling_status = tool_lng_telegram_polling_server(operation="status")
            
            return {
                "super_empath": status,
                "polling_server": polling_status
            }
            
        elif operation == "process_message":
            if not message:
                return {"error": "message is required for process_message operation"}
            
            # –ü—Ä–æ—Å—Ç–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –¥–µ–º–æ)
            def improve_message_sync(msg: str) -> str:
                """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —É–ª—É—á—à–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è"""
                msg_lower = msg.lower()
                
                if any(word in msg_lower for word in ["–¥–æ—Å—Ç–∞–ª", "–±–µ—Å–∏—à—å", "–Ω–∞–¥–æ–µ–ª"]):
                    return "–Ø —á—É–≤—Å—Ç–≤—É—é —É—Å—Ç–∞–ª–æ—Å—Ç—å –æ—Ç —Å–∏—Ç—É–∞—Ü–∏–∏, –º–æ–∂–µ–º —ç—Ç–æ –æ–±—Å—É–¥–∏—Ç—å?"
                elif any(word in msg_lower for word in ["–¥—É—Ä–∞–∫", "–∏–¥–∏–æ—Ç", "—Ç—É–ø–æ–π"]):
                    return "–£ –º–µ–Ω—è –µ—Å—Ç—å –¥—Ä—É–≥–æ–µ –º–Ω–µ–Ω–∏–µ –ø–æ —ç—Ç–æ–º—É –≤–æ–ø—Ä–æ—Å—É, –¥–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º—Å—è"
                elif any(word in msg_lower for word in ["–Ω–µ —Ö–æ—á—É", "–Ω–µ –±—É–¥—É", "–æ—Ç—Å—Ç–∞–Ω—å"]):
                    return "–ú–Ω–µ —Å–µ–π—á–∞—Å —Å–ª–æ–∂–Ω–æ —ç—Ç–æ –¥–µ–ª–∞—Ç—å, –º–æ–∂–µ–º –Ω–∞–π—Ç–∏ –∫–æ–º–ø—Ä–æ–º–∏—Å—Å?"
                elif "!" in msg and len(msg) > 20:
                    return msg.replace("!", ".").strip() + " –ß—Ç–æ –¥—É–º–∞–µ—à—å?"
                else:
                    return f"–Ø —Ö–æ—Ç–µ–ª —Å–∫–∞–∑–∞—Ç—å: {msg}. –ö–∞–∫ —Å—á–∏—Ç–∞–µ—à—å?"
            
            improved = improve_message_sync(message)
            
            return {
                "original": message,
                "improved": improved,
                "status": "processed"
            }
            
        else:
            return {"error": f"Unknown operation: {operation}"}
            
    except Exception as e:
        logger.error(f"Error in super empath tool: {e}")
        return {"error": str(e)}

async def run_tool(name: str, parameters: dict) -> list[types.Content]:
    """Executes the Super Empath tool."""
    try:
        result = tool_lng_telegram_super_empath(**parameters)
        return [types.TextContent(type="text", text=json.dumps(result, indent=2, ensure_ascii=False))]
    except Exception as e:
        error_result = {"error": str(e)}
        return [types.TextContent(type="text", text=json.dumps(error_result, ensure_ascii=False))]
